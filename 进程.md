## 进程间通信
- 信号
- 信号量
- 匿名管道
- 有名管道
- 高级管道
- socket
- 共享内存
- Binder(Android常考)

### Binder机制
传统IPC方式中的数据拷贝过程如下图

![拷贝过程图](http://p1.pstatp.com/large/pgc-image/5b391412f26f4a4aa5d68a1db0dd0a04)

缺点：

1、性能低下，一次数据传递需要经历：（发送进程）内存缓存区 --> 内核缓存区 --> （接受进程）内存缓存区，需要 2 次数据拷贝；

2、接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。

而Binder数据拷贝过程如下图

![拷贝过程图](http://p3.pstatp.com/large/pgc-image/84150198c8a44bb187bdee73c99c4496)


  跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这得益于Linux 的动态内核可加载模块（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。

**在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 Binder 驱动（Binder Dirver）**

Binder IPC 机制中涉及到的内存映射通过 _mmap()_ 来实现，_mmap()_ 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。

内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。

一次完整的 Binder IPC 通信过程通常是这样：

  1、首先 Binder 驱动在内核空间创建一个数据接收缓存区；
  
  2、接着在内核空间开辟一块内核缓存区，建立内核缓存区和内核中数据接收缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间地址的映射关系；
  
  3、发送方进程通过系统调用 _copyfromuser()_ 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。


参考引用：https://blog.csdn.net/AndroidStudyDay/article/details/93749470
